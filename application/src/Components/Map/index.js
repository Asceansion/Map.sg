import React, { useEffect, useState, useRef } from 'react';
import { connect } from "react-redux";

import mapboxgl from 'mapbox-gl';
import 'mapbox-gl/dist/mapbox-gl.css';
import '@mapbox/mapbox-gl-directions/dist/mapbox-gl-directions.css'
import { makeStyles } from '@material-ui/core/styles';
import { Paper, IconButton, Typography } from '@material-ui/core';
import { ChevronLeft, ChevronRight } from '@material-ui/icons';
import { overrideUserLocation } from '../../Action/HomeActions';

const useStyles = makeStyles((theme) => ({
    paper: {
        position: 'fixed',
        width: "100%",
        zIndex: '5',
        flexGrow: 1,
    },
    instr: {
        flexGrow: 1,
    },
    stepsButton: {
        marginRight: theme.spacing(2),
    },
  }));

const mapStateToProps = (state) => {
    const appState = {
            userLocation: state.HomeReducer.userLocation,
            navigationRoute: state.NavigationReducer.navigationRoute,
            startLocation: state.NavigationReducer.startLocation,
            endLocation: state.NavigationReducer.endLocation,
        };
    return appState;
};

function mapDispatchToProps (dispatch) {
    return {
        overrideUserLocation:  newCoords => dispatch(overrideUserLocation(newCoords)),
    }
}

  /* *
    * 
    * Map components handle events related to the map generated by MapboxApi. Routes set by user
    * will be drawn out on the map here and traffic images will be retrieved from govtech and placed
    * here as well
    * 
    * @Koh Tong Liang
    * @Version 1.0
    * @Since 19/10/2018
    * */
function MapBoxView (props) {
    const [routeInstruction, setRouteInstruction] = useState(null);
    const [ongoingTrip, setOngoingTrip] = useState(false);
    const [stepNo, setStepNo] = useState(null);
    const [route, setRoute] = useState(null);
    const [map, setMap] = useState(null);
    const [stepMarkers, setStepMarkers] = useState([]);
    const mapContainer = useRef("");
    var marker = new mapboxgl.Marker();
    mapboxgl.accessToken = process.env.REACT_APP_MAPBOX_KEY;
    const classes = useStyles();

   /* *
    * Create a map object, and load it into the component. Render it.
    * Maybe move this to a middleware.
    * 
    * @Koh Tong Liang
    * @Version 1.0
    * @Since 19/10/2020
    * */
    useEffect(() => {
        // init map function
        const initializeMap = ({ setMap, mapContainer }) => {
            const map = new mapboxgl.Map({
                container: mapContainer.current,
                style: "mapbox://styles/mapbox/streets-v11", // stylesheet location
                center: [103.6831, 1.3483],
                zoom: 17,
                pitch: 45,
            });
        
            map.on("load", () => {
                // Insert the layer beneath any symbol layer.
                var layers = map.getStyle().layers;
                var labelLayerId;
                for (var i = 0; i < layers.length; i++) {
                    if (layers[i].type === 'symbol' && layers[i].layout['text-field']) {
                        labelLayerId = layers[i].id;
                        break;
                    }
                }
                
                // Code for making the buildings look 3D on the map
                map.addLayer(
                {
                    'id': '3d-buildings',
                    'source': 'composite',
                    'source-layer': 'building',
                    'filter': ['==', 'extrude', 'true'],
                    'type': 'fill-extrusion',
                    'minzoom': 15,
                    'paint': {
                    'fill-extrusion-color': '#aaa',
                    
                    // use an 'interpolate' expression to add a smooth transition effect to the
                    // buildings as the user zooms in
                    'fill-extrusion-height': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    15,
                    0,
                    15.05,
                    ['get', 'height']
                    ],
                    'fill-extrusion-base': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    15,
                    0,
                    15.05,
                    ['get', 'min_height']
                    ],
                    'fill-extrusion-opacity': 0.6
                    }
                }, labelLayerId);

                setMap(map);
                map.resize();
            });

            /*
            * FOR DEBUGGING and DEMO only
            * on click set user current location
            * used as temporary override user location
            */
            map.on('click', (e) => {
                props.overrideUserLocation({
                    lng: e.lngLat.lng,
                    lat: e.lngLat.lat,
                });
            });
        };

        if (!map) {
            // if map not yet initialized, initialize it
            initializeMap({ setMap, mapContainer });
        }
    }, [map]);


    /* *
    * 
    * When userlocation change, detect if user has reach waypoint, if user has reach the
    * waypoint, remove the marker on the waypoint and progress to next step in step by step
    * instruction
    * 
    * @Koh Tong Liang
    * @Version 1.0
    * @Since 19/10/2020
    * */
    useEffect(() => {
        if (map != null && props.userLocation.length > 0) {
            map.flyTo({
                center: [props.userLocation[0].lng, props.userLocation[0].lat]
            });
            marker.setLngLat([props.userLocation[0].lng, props.userLocation[0].lat]);

            if (marker !== undefined && stepMarkers[stepNo] !== undefined) {
                if ((marker.getLngLat().lng - stepMarkers[stepNo].getLngLat().lng <= 0.0005 ||
                    marker.getLngLat().lng - stepMarkers[stepNo].getLngLat().lng >= -0.0005) &&
                    (marker.getLngLat().lat - stepMarkers[stepNo].getLngLat().lat <= 0.0005 ||
                    marker.getLngLat().lat - stepMarkers[stepNo].getLngLat().lat >= -0.0005)) {
                    stepMarkers[stepNo].remove();
                    setStepNo(stepNo => stepNo + 1);
                }
            }
            
            marker.addTo(map);
        }
    }, [props.userLocation])

    /* *
    * To Be Shifted
    * */
    // const setUpTrafficImages = () => {
    //     axios.get('https://api.data.gov.sg/v1/transport/traffic-images').then(function (response) {
    //         // console.log(response.data.items);

    //         response.data.items[0].cameras.map(camera => {
    //             var el = document.createElement('img');
    //             el.className = 'marker';
    //             el.src = camera.image;
    //             // el.style.backgroundImage = camera.image;
    //             el.style.width = '120px';
    //             el.style.height = '120px';
    //             // el.addEventListener('click', function () {
    //             //     window.alert(instruction.maneuver.instruction);
    //             // });

    //             let stepMarkers = new mapboxgl.Marker(el);
    //             stepMarkers.setLngLat([camera.location.longitude, camera.location.latitude]);
    //             stepMarkers.addTo(map);
    //         });
    //     }).catch(function (error) {
    //         console.log(error);
    //     });
    // }

        useEffect(() => {
            if (props.navigationRoute !== [] && props.navigationRoute.length > 0 ) {
                map.flyTo({
                    center: [props.startLocation[0].lng, props.startLocation[0].lat]
                });
                // setting up path
                setStepNo(0);
                setRouteInstruction([]);
                var steps = 1;
                props.navigationRoute[0].data.routes[0].legs[0].steps.forEach(instruction => {
                    var el = document.createElement('div');
                    el.className = 'marker';
                    el.style.backgroundColor = "black";
                    el.style.textAlign = "center";
                    el.textContent = steps;
                    el.style.width = '30px';
                    el.style.height = '30px';

                    let step = new mapboxgl.Marker(el);
                    step.setLngLat(instruction.maneuver.location);
                    step.addTo(map);
                    setRouteInstruction(routeInstruction => [...routeInstruction, instruction]);
                    setStepMarkers(stepMarkers => [...stepMarkers, step]);
                    steps++;
                });

                // display step by step instruction
                // plotting route on the map
                var coordinates = props.navigationRoute[0].data.routes[0].geometry;
                setRoute(coordinates);

                map.addSource('Route', {
                    'type': 'geojson',
                    'data': coordinates
                });

                map.addLayer({
                    'id': 'Route',
                    'type': 'line',
                    'source': 'LineString',
                    'layout': {
                    'line-join': 'round',
                    'line-cap': 'round'
                    },
                    'paint': {
                    'line-color': '#BF93E4',
                    'line-width': 5
                    }
                });

                let startMarker = new mapboxgl.Marker();
                startMarker.setLngLat(props.startLocation[0]);
                startMarker.addTo(map);

                let destinationMarker = new mapboxgl.Marker();
                destinationMarker.setLngLat(props.endLocation[0]);
                destinationMarker.addTo(map);

                // setUpTrafficImages();
            }
        }, [props.navigationRoute]);

    return (
        <div>
            {(routeInstruction && routeInstruction.length > 0) && (
                <Paper className={classes.paper} elevation={5}>
                    <IconButton className={classes.stepsButton} color="inherit" onClick={() => stepNo > 0 ? setStepNo(stepNo => stepNo - 1) : stepNo}>
                        <ChevronLeft/>
                    </IconButton>
                    <Typography variant="p" className={classes.instr}>
                        {routeInstruction[stepNo].maneuver.instruction}
                    </Typography>
                    <IconButton className={classes.stepsButton} color="inherit" onClick={() => stepNo < routeInstruction.length - 1 ? setStepNo(stepNo => stepNo + 1) : stepNo}>
                        <ChevronRight/>
                    </IconButton>
                </Paper>
            )}

            <div style={{ zIndex: "-1", position: "absolute", width: '100%', height: '100%', top: 0, bottom: 0}} ref={el => (mapContainer.current = el)}></div>
        </div>
    )
}

const MapBox = connect(
    mapStateToProps,
    mapDispatchToProps,
)(MapBoxView)

export default MapBox;
