import React, { useEffect, useState, useRef } from 'react';
import { connect } from "react-redux";

import * as turf from '@turf/turf';
import mapboxgl from 'mapbox-gl';
import 'mapbox-gl/dist/mapbox-gl.css';
import '@mapbox/mapbox-gl-directions/dist/mapbox-gl-directions.css'
import { makeStyles } from '@material-ui/core/styles';
import { Paper, IconButton, Typography } from '@material-ui/core';
import { ChevronLeft, ChevronRight, ContactSupportOutlined } from '@material-ui/icons';
import { overrideUserLocation } from '../../Action/HomeActions';
import { getTrafficImages, getErpData, updateCameraMarkers } from '../../Action/MapActions';
import { tripSummary, mapMatching, updateSteps } from '../../Action/NavigationActions';
import TripSummary from '../Map/TripSummary';

const useStyles = makeStyles((theme) => ({
    paper: {
        position: 'fixed',
        width: "100%",
        zIndex: '5',
        flexGrow: 1,
    },
    instr: {
        flexGrow: 1,
    },
    stepsButton: {
        marginRight: theme.spacing(2),
    },
  }));

const mapStateToProps = (state) => {
    const appState = {
            userLocation: state.HomeReducer.userLocation,
            navigationRoute: state.NavigationReducer.navigationRoute,
            startLocation: state.NavigationReducer.startLocation,
            endLocation: state.NavigationReducer.endLocation,
            mapMatchedRoute: state.NavigationReducer.mapMatchedRoute,
            cameras: state.MapReducer.cameras,
            ERP: state.MapReducer.ERP,
            cameraMarkers: state.MapReducer.cameraMarkers,
            stepNo: state.NavigationReducer.stepNo,
            routeInstruction: state.NavigationReducer.routeInstruction,
        };
    return appState;
};

function mapDispatchToProps (dispatch) {
    return {
        overrideUserLocation:  newCoords => dispatch(overrideUserLocation(newCoords)),
        getTrafficImages: () => dispatch(getTrafficImages()),
        getErpData: () => dispatch(getErpData()),
        tripSummary: () => dispatch(tripSummary()),
        mapMatching: routeCoordinates => dispatch(mapMatching(routeCoordinates)),
        updateCameraMarkers: cameraMarker => dispatch(updateCameraMarkers(cameraMarker)),
        updateSteps: stepNo => dispatch(updateSteps(stepNo)),
    }
}

 /* *
    * 
    * Map components handle events related to the map generated by MapboxApi. Routes set by user
    * will be drawn out on the map here and traffic images will be retrieved from govtech and placed
    * here as well
    * 
    * @Koh Tong Liang
    * @Version 1.0
    * @Since 19/10/2018
    * */
function MapBoxView (props) {
    const [map, setMap] = useState(null);
    const [stepMarkers, setStepMarkers] = useState([]);
    const [pinnedCameraMarkers, setPinnedCameraMarkers] = useState([]);
    const mapContainer = useRef("");
    var marker = new mapboxgl.Marker();
    mapboxgl.accessToken = process.env.REACT_APP_MAPBOX_KEY;
    const classes = useStyles();

    /**
     * On component mount, gather ERP rates and traffic images
     */
    useEffect(() => {
        props.getTrafficImages();
        props.getErpData();
    })

   /* *
    * MAP INIT
    * Create a map object, and load it into the component. Render it.
    * Maybe move this to a middleware.
    * 
    * @Koh Tong Liang
    * @Version 1.0
    * @Since 19/10/2020
    * */
    useEffect(() => {
        // init map function
        const initializeMap = ({ setMap, mapContainer }) => {
            const map = new mapboxgl.Map({
                container: mapContainer.current,
                style: "mapbox://styles/mapbox/streets-v11", // stylesheet location
                center: [103.6831, 1.3483],
                zoom: 17,
                pitch: 45,
            });
        
            map.on("load", () => {
                // Insert the layer beneath any symbol layer.
                var layers = map.getStyle().layers;
                var labelLayerId;
                for (var i = 0; i < layers.length; i++) {
                    if (layers[i].type === 'symbol' && layers[i].layout['text-field']) {
                        labelLayerId = layers[i].id;
                        break;
                    }
                }
                
                // Code for making the buildings look 3D on the map
                map.addLayer({
                    'id': '3d-buildings',
                    'source': 'composite',
                    'source-layer': 'building',
                    'filter': ['==', 'extrude', 'true'],
                    'type': 'fill-extrusion',
                    'minzoom': 15,
                    'paint': {
                    'fill-extrusion-color': '#aaa',
                    
                    // use an 'interpolate' expression to add a smooth transition effect to the
                    // buildings as the user zooms in
                    'fill-extrusion-height': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    15,
                    0,
                    15.05,
                    ['get', 'height']
                    ],
                    'fill-extrusion-base': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    15,
                    0,
                    15.05,
                    ['get', 'min_height']
                    ],
                    'fill-extrusion-opacity': 0.6
                    }
                }, labelLayerId);

                setMap(map);
                map.resize();
            });

            /*
            * FOR DEBUGGING and DEMO only
            * on click set user current location
            * used as temporary override user location
            */
            map.on('click', (e) => {
                props.overrideUserLocation({
                    lng: e.lngLat.lng,
                    lat: e.lngLat.lat,
                });
            });
        };

        if (!map) {
            // if map not yet initialized, initialize it
            initializeMap({ setMap, mapContainer });
        }
    }, [map]);

 /* *
    * USER LOCATION CHANGE
    * When userlocation change, detect if user has reach waypoint, if user has reach the
    * waypoint, remove the marker on the waypoint and progress to next step in step by step
    * instruction
    * 
    * @Koh Tong Liang
    * @Version 1.0
    * @Since 19/10/2020
    * */
    useEffect(() => {
        if (map != null && props.userLocation.length > 0) {
            map.flyTo({
                center: [props.userLocation[0].lng, props.userLocation[0].lat]
            });

            if (marker !== undefined) {
                marker.remove();
            }

            marker.setLngLat([props.userLocation[0].lng, props.userLocation[0].lat]);
            const stepNo = props.stepNo;
            if (marker !== undefined && stepMarkers[stepNo] !== undefined) {
                // detect if user has reached a checkpoint
                if ((marker.getLngLat().lng - stepMarkers[stepNo].getLngLat().lng <= 0.0005 &&
                    marker.getLngLat().lng - stepMarkers[stepNo].getLngLat().lng >= -0.0005) &&
                    (marker.getLngLat().lat - stepMarkers[stepNo].getLngLat().lat <= 0.0005 &&
                    marker.getLngLat().lat - stepMarkers[stepNo].getLngLat().lat >= -0.0005)) {
                    stepMarkers[stepNo].remove();

                    if (props.stepNo < props.routeInstruction.length - 1) {
                        props.updateSteps(props.stepNo + 1);
                    } else {
                        // User reaches end of the route
                        props.tripSummary();
                        map.removeSource('LineString');
                        map.removeLayer('LineString');
                        props.updateSteps(0);
                        pinnedCameraMarkers.map(c => {
                            c.remove();
                        });
                        
                        setStepMarkers([]);
                        props.updateCameraMarkers([]);
                    }
                }
            }
            marker.addTo(map);
        }
    }, [props.userLocation])

    /**
     * ROUT PLOTTING
     * When a route has been set
     */
    useEffect(() => {
        if (props.navigationRoute !== [] && props.navigationRoute.length > 0 ) {
            map.flyTo({
                center: [props.startLocation[0].lng, props.startLocation[0].lat]
            });

            // setting up path
            var steps = 1;
            props.navigationRoute[0].data.routes[0].legs[0].steps.forEach(instruction => {
                var el = document.createElement('div');
                el.className = 'marker';
                el.style.backgroundColor = "black";
                el.style.textAlign = "center";
                el.textContent = steps;
                el.style.width = '30px';
                el.style.height = '30px';

                let step = new mapboxgl.Marker(el);
                step.setLngLat(instruction.maneuver.location);
                step.addTo(map);
                setStepMarkers(stepMarkers => [...stepMarkers, step]);
                steps++;
            });

            // display step by step instruction
            // plotting route on the map
            var coordinates = props.navigationRoute[0].data.routes[0].geometry;
            
            map.addSource('LineString', {
                'type': 'geojson',
                'data': coordinates
            });
            map.addLayer({
                'id': 'LineString',
                'type': 'line',
                'source': 'LineString',
                'layout': {
                'line-join': 'round',
                'line-cap': 'round'
                },
                'paint': {
                'line-color': '#BF93E4',
                'line-width': 5
                }
            });

            let startMarker = new mapboxgl.Marker();
            startMarker.setLngLat(props.startLocation[0]);
            startMarker.addTo(map);

            let destinationMarker = new mapboxgl.Marker();
            destinationMarker.setLngLat(props.endLocation[0]);
            destinationMarker.addTo(map);

            // Detect if there is any traffic cameras on the way
            let cameraArr = [];
            props.cameras.map(c => {
                var cameraPosition = { lng: c.location.longitude, lat: c.location.latitude };
                // detect if route plot by mapbox intersects position of camera
                var points = turf.lineIntersect(turf.lineString(coordinates.coordinates), turf.polygon([[[cameraPosition.lng+0.0005, cameraPosition.lat],
                     [cameraPosition.lng, cameraPosition.lat+0.0005],[cameraPosition.lng-0.0005, cameraPosition.lat], [cameraPosition.lng, cameraPosition.lat-0.0005],[cameraPosition.lng+0.0005, cameraPosition.lat]]]));
                if (points.features.length > 0) {
                    var el = document.createElement('img');
                    el.src = c.image;
                    el.style.textAlign = "center";
                    el.style.width = '80px';
                    el.style.height = '80px';
    
                    let cameraMarker = new mapboxgl.Marker(el);
                    cameraMarker.setLngLat(cameraPosition);
                    cameraMarker.addTo(map);
                    setPinnedCameraMarkers(pinnedCameraMarkers => [...pinnedCameraMarkers, cameraMarker]);
                    cameraArr.push(c);
                }
            });

            // store only cameras on the route to destination
            props.updateCameraMarkers(cameraArr);
        } else {
            if (map != null) {
                map.removeSource('LineString');
                map.removeLayer('LineString');
                pinnedCameraMarkers.map(c => {
                    c.remove();
                });
                stepMarkers.map(s => {
                    s.remove();
                });
                setPinnedCameraMarkers([]);
                setStepMarkers([]);
                props.updateCameraMarkers([]);
            }
        }
    }, [props.navigationRoute]);

    return (
        <div>
            {/* Turn by turn instruction banner */}
            {(props.routeInstruction && props.routeInstruction.length > 0) && (
                <Paper className={classes.paper} elevation={5}>
                    <IconButton className={classes.stepsButton} color="inherit" onClick={() => props.stepNo > 0 ? props.updateSteps(props.stepNo + 1) : props.stepNo}>
                        <ChevronLeft/>
                    </IconButton>
                    <Typography variant="p" className={classes.instr}>
                        {props.routeInstruction[props.stepNo].maneuver.instruction}
                    </Typography>
                    <IconButton className={classes.stepsButton} color="inherit" onClick={() => props.stepNo < props.routeInstruction.length - 1 ? props.updateSteps(props.stepNo + 1) : props.stepNo}>
                        <ChevronRight/>
                    </IconButton>
                </Paper>
            )}

            {/* TripSummary */}
            <TripSummary/>

            {/* Map element */}
            <div style={{ zIndex: "-1", position: "absolute", width: '100%', height: '100%', top: 0, bottom: 0}} ref={el => (mapContainer.current = el)}></div>
        </div>
    )
}

const MapBox = connect(
    mapStateToProps,
    mapDispatchToProps,
)(MapBoxView)

export default MapBox;
